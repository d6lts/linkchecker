<?php
// $Id$

/**
 * @file
 * This module periodically check links in given node types, blocks, cck fields, etc.
 *
 * Developed by Alexander Hass, http://www.yaml-for-drupal.com/.
 */

/**
 * Implementation of hook_perm().
 */
function linkchecker_perm() {
  return array('access linkchecker', 'administer linkchecker');
}

/**
 * Implementation of hook_help().
 */
function linkchecker_help($path, $arg) {
  switch ($path) {
    case 'admin/help#linkchecker':
      $output = '<p>';
      $output .= t('This module provides an aid to finding broken links on your site. It periodically checks contents of all public nodes, tries to find any html links and check for their validity. It reports broken links through the admin interface. For more information about status codes see <a href="@rfc">Status Code Definitions</a>.', array('@rfc' => 'http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html'));
      $output .= '</p>';
      return $output;
  }
}

/**
 * Implementation of hook_menu().
 */
function linkchecker_menu() {

  $items['admin/settings/linkchecker'] = array(
    'title' => 'Link checker',
    'description' => 'Link checker configuration',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('linkchecker_admin_settings_form'),
    'access arguments' => array('administer linkchecker'),
    'file' => 'linkchecker.admin.inc',
  );
  $items['admin/reports/linkchecker'] = array(
    'title' => 'Broken links',
    'description' => 'Shows a list of broken links in content.',
    'page callback' => 'linkchecker_admin_report',
    'type' => MENU_NORMAL_ITEM,
    'access arguments' => array('access linkchecker'),
    'file' => 'linkchecker.admin.inc',
  );

  return $items;
}

/**
 * Batch: Load all nodes 10 by ten.
 */
function _linkchecker_batch_import_nodes() {
  // TODO: Add limitation setting and test with 500.000+ nodes and review memory consumption.
  $limit = 10;

  // Node import.
  $operations = array();
  $nids = db_result(db_query('SELECT COUNT(DISTINCT nid) FROM {node} WHERE status = %d', 1));
  for ($nid = 0; $nid<$nids; $nid = $nid+$limit) {
    $operations[] = array('_linkchecker_batch_node_import_op', array($nid, $limit));
  }
  $batch = array(
    'operations' => $operations,
    'finished' => '_linkchecker_batch_node_import_finished',
    'title' => t('Scanning nodes for links'),
  );

  return $batch;
}

/**
 * Batch operation: Load all nodes, 10 by ten.
 */
function _linkchecker_batch_node_import_op($nid, $limit, &$context) {
  // Retrieve the next group of nids.
  $result = db_query_range("SELECT nid FROM {node} WHERE nid > %d AND status = %d ORDER BY nid ASC", $nid, 1, 0, $limit);

  while ($row = db_fetch_array($result)) {
    // Load the node and scan for links.
    $node = node_load($row['nid'], NULL, TRUE);
    _linkchecker_add_node_links($node);

    // Store results for post-processing in the finished callback.
    // TODO: Test with 500.000+ nodes and review memory consumption.
    $context['results'][] = $node->nid;
  }
}

function _linkchecker_batch_node_import_finished($success, $results, $operations) {
  if ($success) {
    $message = format_plural(count($results), 'One node has been scanned.', '@count nodes have been scanned.');
  }
  else {
    $message = t('Finished importing nodes with an error.');
  }
  drupal_set_message($message);
}

/**
 * Batch: Load all nodes 10 by ten.
 */
function _linkchecker_batch_import_boxes() {
  // TODO: Add limitation setting and test with 500.000+ boxes and review memory consumption.
  $limit = 10;

  // Block import.
  $operations = array();
  $bids = db_result(db_query('SELECT bid FROM {boxes}'));
  for ($bid = 0; $bid<$bids; $bid = $bid+$limit) {
    $operations[] = array('_linkchecker_batch_import_boxes_op', array($bid, $limit));
  }
  $batch = array(
    'operations' => $operations,
    'finished' => '_linkchecker_batch_box_import_finished',
    'title' => t('Scanning boxes for links'),
  );

  return $batch;
}

/**
 * Batch operation: Load all boxes, 10 by ten.
 */
function _linkchecker_batch_import_boxes_op($bid, $limit, &$context) {
  // Retrieve the next group of bids.
  $result = db_query_range("SELECT bid FROM {boxes} WHERE bid > %d ORDER BY bid ASC", $bid, 0, $limit);

  while ($row = db_fetch_array($result)) {
    // Load the box and scan for links.
    $box = block_box_get($row['bid']);
    _linkchecker_add_box_links($box, $row['bid']);

    // Store some result for post-processing in the finished callback.
    $context['results'][] = $box['bid'];
  }
}

function _linkchecker_batch_box_import_finished($success, $results, $operations) {
  if ($success) {
    $message = format_plural(count($results), 'One box has been scanned.', '@count boxes have been scanned.');
  }
  else {
    $message = t('Finished importing boxes with an error.');
  }
  drupal_set_message($message);
}

/**
 * Implementation of hook_cron().
 */
function linkchecker_cron() {

  // Remove outdated links no longer in use.
  if (time() - variable_get('linkchecker_cleanup_links_last', 0) >= variable_get('linkchecker_cleanup_links_interval', 604800)) {
    _linkchecker_cleanup_links();
    variable_set('linkchecker_cleanup_links_last', time());
  }

  // TODO: Implement cURL support.
  //$has_curl = function_exists('curl_init');

  // Get URLs for checking.
  $check_links_max_per_cron_run = variable_get('linkchecker_check_links_max', 10);
  $check_links_interval = variable_get('linkchecker_check_links_interval', 2419200);
  $useragent = variable_get('linkchecker_check_useragent', 'Drupal (+http://drupal.org/)');
  $ignore_response_codes = preg_split('/(\r\n?|\n)/', variable_get('linkchecker_ignore_response_codes', "200\n304\n401\n403"));

  $result = db_query_range("SELECT * FROM {linkchecker_links} WHERE last_checked < %d", time() - $check_links_interval, 0, $check_links_max_per_cron_run);
  while ($link = db_fetch_object($result)) {
    // Fetch URL.
    $response = drupal_http_request($link->url, array('User-Agent' => 'User-Agent: ' . $useragent), $link->method, NULL, 0);

    switch ($response->code) {
      case 200:
      case 304:
        db_query("UPDATE {linkchecker_links} SET code = %d, error = '%s', fail_count = %d, last_checked = %d WHERE lid = %d", $response->code, $response->error, 0, time(), $link->lid);
        //watchdog('linkchecker', 'Checked %link successfully.', array('%link' => $link->url), WATCHDOG_INFO);
        break;

      case 301:
        db_query("UPDATE {linkchecker_links} SET code = %d, error = '%s', fail_count = fail_count+1, last_checked = %d WHERE lid = %d", $response->code, $response->error, time(), $link->lid);

        // A HTTP status code of 301 tells us an existing link have changed to
        // a new link. The remote site owner was so kind to provide us the new
        // link and if we trust this change we are able to replace the old link
        // with the new one without any hand work.
        $auto_repair_301 = variable_get('linkchecker_action_status_code_301', 0);
        if ($auto_repair_301 && $auto_repair_301 <= ($link->fail_count+1)) {

          // NODES: Autorepair all nodes having this outdated link.
          $res = db_query("SELECT * FROM {linkchecker_nodes} WHERE lid = %d", $link->lid);
          while ($row = db_fetch_object($res)) {
            $node = node_load(array('nid' => $row->nid));

            // Now replace the outdated link with the permanently moved one in
            // all node fields.
            // TODO: Add CCK fields and others.
            if (!empty($node->title)) {
              $node->title = str_replace($link->url, check_url($response->redirect_url), $node->title);
              $node->title = str_replace(check_url($link->url), check_url($response->redirect_url), $node->title);
            }
            if (!empty($node->body)) {
              $node->body = str_replace($link->url, check_url($response->redirect_url), $node->body);
              $node->body = str_replace(check_url($link->url), check_url($response->redirect_url), $node->body);
            }

            // Save changed node and update the node link list.
            node_save($node);
            // TODO: Logic could theoretically be optimized for more speed -> do
            // the link update only once and not after every changed link (minor).
            _linkchecker_add_node_links($node);
            watchdog('linkchecker', 'Changed permanently moved link in %node from %src to %dst.', array('%node' => url('node/' . $row->nid), '%src' => $link->url, '%dst' => $response->redirect_url), WATCHDOG_INFO);
          }

          // BOXES: Autorepair all boxes having this outdated link.
          $res = db_query("SELECT * FROM {linkchecker_boxes} WHERE lid = %d", $link->lid);
          while ($row = db_fetch_object($res)) {
            $box = block_box_get($row->bid);

            // Now replace the outdated link with the permanently moved one in all box fields.
            if (!empty($box['info'])) {
              $box['info'] = str_replace($link->url, check_url($response->redirect_url), $box['info']);
              $box['info'] = str_replace(check_url($link->url), check_url($response->redirect_url), $box['info']);
            }
            if (!empty($box['body'])) {
              $box['body'] = str_replace($link->url, check_url($response->redirect_url), $box['body']);
              $box['body'] = str_replace(check_url($link->url), check_url($response->redirect_url), $box['body']);
            }

            // Save changed node and update the node link list.
            block_box_save($box, $row->bid);
            // TODO: Logic could theoretically be optimized for more speed -> do
            // the link update only once and not after every changed link (minor).
            _linkchecker_add_box_links($box, $row->bid);
            watchdog('linkchecker', 'Changed permanently moved link in box %bid from %src to %dst.', array('%bid' => $row->bid, '%src' => $link->url, '%dst' => $response->redirect_url), WATCHDOG_INFO);
          }

        }
        else {
          watchdog('linkchecker', 'Link %link has changed and needs to be updated.', array('%link' => $link->url), WATCHDOG_NOTICE, url('admin/reports/linkchecker'));
        }
        break;

      case 404:
        db_query("UPDATE {linkchecker_links} SET code = %d, error = '%s', fail_count = fail_count+1, last_checked = %d WHERE lid = %d", $response->code, $response->error, time(), $link->lid);
        watchdog('linkchecker', 'Broken link @link has been found.', array('@link' => $link->url), WATCHDOG_NOTICE, url('admin/reports/linkchecker'));

        // If unpublishing limit is reached, unpublish all nodes having this link.
        $linkchecker_action_status_code_404 = variable_get('linkchecker_action_status_code_404', 0);
        if ($linkchecker_action_status_code_404 && $linkchecker_action_status_code_404 <= ($link->fail_count+1)) {
          _linkchecker_unpublish_nodes($link->lid);
        }
        break;

      case 405:
        // Special error handling if method is not allowed. Switch link checking to GET method and try again.
        $response = drupal_http_request($link->url, array('User-Agent' => 'User-Agent: ' . $useragent), 'GET', NULL, 0);
        if ($response->code == 200) {
          db_query("UPDATE {linkchecker_links} SET code = %d, error = '%s', fail_count = %d, last_checked = %d, method = '%s' WHERE lid = %d", $response->code, $response->error, 0, time(), 'GET', $link->lid);
        }
        else {
          db_query("UPDATE {linkchecker_links} SET code = %d, error = '%s', fail_count = fail_count+1, last_checked = %d, method = '%s' WHERE lid = %d", $response->code, $response->error, time(), 'GET', $link->lid);
        }
        watchdog('linkchecker', 'Method HEAD is not allowed for link @link. Method has been changed to GET.', array('@link' => $link->url), WATCHDOG_INFO, url('admin/reports/linkchecker'));
        break;

      default:
        // Don't treat ignored response codes as errors.
        if (in_array($response->code, $ignore_response_codes)) {
          db_query("UPDATE {linkchecker_links} SET code = %d, error = '%s', fail_count = %d, last_checked = %d WHERE lid = %d", $response->code, $response->error, 0, time(), $link->lid);
          //watchdog('linkchecker', 'Unhandled link error @link has been found.', array('@link' => $link->url), WATCHDOG_ERROR, url('admin/reports/linkchecker'));
        }
        else {
          db_query("UPDATE {linkchecker_links} SET code = %d, error = '%s', fail_count = fail_count+1, last_checked = %d WHERE lid = %d", $response->code, $response->error, time(), $link->lid);
          //watchdog('linkchecker', 'Unhandled link error @link has been found.', array('@link' => $link->url), WATCHDOG_ERROR, url('admin/reports/linkchecker'));
        }
    }
  }
}

function linkchecker_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'insert':
    case 'update':
      // The node is going to be published.
      if (!empty($node->moderate) && _linkchecker_scan_nodetype($node->type)) {
        _linkchecker_add_node_links($node);

        // TODO: Scan CCK text fields (http://drupal.org/project/cck).
        if (module_exists('text')) {
        }
        // TODO: Scan CCK link fields (http://drupal.org/project/link).
        if (module_exists('link')) {
        }
      }
      break;

    case 'delete':
      _linkchecker_delete_node_links($node);
      break;

    case 'view':
      // Node edit tab is viewed.
      if (arg(2) == 'edit') {
        // Show a message if a link check failed once or more.
        $ignore_response_codes = preg_split('/(\r\n?|\n)/', variable_get('linkchecker_ignore_response_codes', "200\n304\n401\n403"));
        $links = db_query("SELECT url, code, fail_count FROM {linkchecker_nodes} ln INNER JOIN {linkchecker_links} ll ON ln.lid = ll.lid WHERE ln.nid = %d AND ll.fail_count > %d AND ll.code NOT IN (" . db_placeholders($ignore_response_codes, 'int') . ")", array_merge(array($node->nid, 0), $ignore_response_codes));
        while ($link = db_fetch_object($links)) {
          drupal_set_message(format_plural($link->fail_count, 'Link check for <a href="@url">@url</a> failed once (status code: @code).', 'Link check for <a href="@url">@url</a> failed @count times (status code: @code).', array('@url' => $link->url, '@code' => $link->code)), 'warning', FALSE);
        }
      }
      break;
  }
}

function linkchecker_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    // Catch the block add/configure form and add custom submit handler.
    case 'block_add_block_form':
      // Add custom submit handler to block add form.
      $form['#submit'][] = 'linkchecker_add_form_submit';
      break;

    case 'block_admin_configure':
      // Add custom submit handler to block configuration form.
      $form['#submit'][] = 'linkchecker_configure_form_submit';
      break;

    case 'block_box_delete':
      $form['#submit'][] = 'linkchecker_box_delete_form_submit';
      break;

    case 'block_admin_display_form':
      // TODO: Add submit handler into admin/build/block to catch "status" value and remove all other obsolete handlers above.
      //$form['#submit'][] = 'linkchecker_admin_display_form_submit';
      break;

    default:
      break;
  }
}

/**
 * Custom submit handler for block add page.
 */
function linkchecker_add_form_submit($form, &$form_state) {
  $bid = db_last_insert_id('boxes', 'bid');
  _linkchecker_add_box_links($form_state['values'], $bid);
}

/**
 * Custom submit handler for block configure page.
 */
function linkchecker_configure_form_submit($form, &$form_state) {
  _linkchecker_add_box_links($form_state['values'], $form_state['values']['delta']);
}

/**
 * Custom submit handler for block delete page.
 */
function linkchecker_box_delete_form_submit($form, &$form_state) {
  _linkchecker_delete_box_links($form_state['values']['bid']);
}

/*
function linkchecker_admin_display_form_submit($form, &$form_state) {

  foreach ($form_state['values'] as $block) {
    $block['status'] = $block['region'] != BLOCK_REGION_NONE;
    //$block['region'] = $block['status'] ? $block['region'] : '';

    //$box = db_fetch_array(db_query("SELECT bl.bid, bl.status, bl.title, bx.info, bx.body FROM {blocks} bl INNER JOIN {boxes} bx ON bx.bid = bl.delta WHERE module = '%s' AND delta = '%s' AND theme = '%s'", $block['module'], $block['delta'], $block['theme']));
    if ($block['delta']) {
      $box = block_box_get($block['delta']);

      // The block is disabled in this theme. Cleanup.
      if ($block['status']) {
        _linkchecker_add_box_links($box, $block['delta']);
        watchdog('linkchecker', 'Scanned block %block.', array('%block' => $block['delta']), WATCHDOG_INFO);
      }
      else {
        db_query("DELETE FROM {linkchecker_boxes} WHERE bid = %d", $block['delta']);
        watchdog('linkchecker', 'Deleted links for block %block.', array('%block' => $block['delta']), WATCHDOG_INFO);
      }
    }
  }
}
 */

/**
 * Add node links into database.
 */
function _linkchecker_add_node_links($node) {

  // Remove all link references first for cleanup reasons...
  _linkchecker_delete_node_links($node->nid);

  // Extract all links in a node.
  $links = _linkchecker_extract_links($node->title . ' ' . $node->body);

  // Only add unique links to database that do not exist.
  foreach (array_unique($links) as $link) {
    // Change HTML links into plain text links.
    $link = decode_entities($link);

    $lid = db_result(db_query("SELECT lid FROM {linkchecker_links} WHERE token = '%s'", md5($link)));
    if (!$lid) {
      db_query("INSERT INTO {linkchecker_links} (token, url) VALUES ('%s', '%s')", md5($link), $link);
      $lid = db_last_insert_id('linkchecker_links', 'lid');
      db_query("INSERT INTO {linkchecker_nodes} (nid, lid) VALUES (%d, %d)", $node->nid, $lid);
    }
    else {
      db_query("INSERT INTO {linkchecker_nodes} (nid, lid) VALUES (%d, %d)", $node->nid, $lid);
    }
  }
}

/**
 * Add box links into database.
 */
function _linkchecker_add_box_links($edit, $bid) {

  // Remove all link references first for cleanup reasons...
  _linkchecker_delete_box_links($bid);

  // Extract all links in a box.
  $links = _linkchecker_extract_links($edit['info'] .' '. $edit['title'] .' '. $edit['body']);

  // Only add unique links to database that do not exist.
  foreach (array_unique($links) as $link) {
    // Change HTML links into plain text links.
    $link = decode_entities($link);

    $lid = db_result(db_query("SELECT lid FROM {linkchecker_links} WHERE token = '%s'", md5($link)));
    if (!$lid) {
      db_query("INSERT INTO {linkchecker_links} (token, url) VALUES ('%s', '%s')", md5($link), $link);
      $lid = db_last_insert_id('linkchecker_links', 'lid');
      db_query("INSERT INTO {linkchecker_boxes} (bid, lid) VALUES (%d, %d)", $bid, $lid);
    }
    else {
      db_query("INSERT INTO {linkchecker_boxes} (bid, lid) VALUES (%d, %d)", $bid, $lid);
    }
  }
}

/**
 * Remove all node references to links in the linkchecker_nodes table.
 */
function _linkchecker_delete_node_links($nid) {
  return db_query("DELETE FROM {linkchecker_nodes} WHERE nid = %d", $nid);
}

/**
 * Remove all box references to links in the linkchecker_boxes table.
 */
function _linkchecker_delete_box_links($bid) {
  return db_query("DELETE FROM {linkchecker_boxes} WHERE bid = %d", $bid);
}

/**
 * Run perodically via cron and delete all links without a references.
 *
 * For speed reasons and check results we keep the links for some time
 * as they may be reused by other new content.
 */
function _linkchecker_cleanup_links() {
  // TODO: Whipe out node types no longder in use.

  // TODO: Requires MySQL 5.x for subselects. Untested with pgsql.
  $query = "DELETE FROM {linkchecker_links}
            WHERE lid NOT IN (
              SELECT lid FROM {linkchecker_boxes}
              UNION ALL
              SELECT lid FROM {linkchecker_nodes}
            )";

  db_query($query);
  watchdog('linkchecker', 'Wiped out obsolete links.', WATCHDOG_INFO);

  return $result;
}

/**
 * Extract links from node content.
 */
function _linkchecker_extract_links($text = '') {

  // Try to find URLs and make them compatible with _linkchecker_extract_links regex.
  $text = _linkchecker_filter_url($text);

  // Finds any links in the content.
  $matches = array();
  preg_match_all("@
    <
    (a|area)
    \s
    (.(?!(href)))*?
    \s*
    (href\s*=\s*['\"]?
    ([^\'#\[%\">][^\'\">]*[^\'\"> ])
    \s*['\"]?)
  @ix", $text, $matches);

  $links = array();
  $ret = $matches[5];
  for ($i=0; isset($ret[$i]); $i++) {
    // Full qualified URLs.
    if (valid_url($ret[$i], TRUE)) {
      $links[] = $ret[$i];
    }
    // Local URLs.
    elseif (valid_url($ret[$i], FALSE)) {
      if (variable_get('linkchecker_fqdn_only', 1) == 0) {
        $links[] = 'http://'. $_SERVER['HTTP_HOST'] . $ret[$i];
      }
    }
  }

  return $links;
}

/**
 * This is a customized clone of the core function _filter_url().
 */
function _linkchecker_filter_url($text = '') {

  $text = ' ' . $text . ' ';

  // Match pathfilter.module URLs prefixed with "internal:" and force them to be absolute for URL checking.
  if (module_exists('pathfilter') && variable_get('linkchecker_pathfilter_support', 0)) {
    $absolute = (variable_get('pathfilter_link_type', 'absolute') == 'absolute' ? 'TRUE' : 'FALSE');
    $text = preg_replace('/"internal:([^"#\?]+)\??([^"#]+)?#?([^"]+)?"/e', "'\"'. url('$1', array('query' => '$2' ? '$2' : NULL, 'fragment' => '$3' ? '$3' : NULL, 'absolute' => " . $absolute . ")) .'\"'", $text);
  }

  // Match absolute URLs.
  $text = preg_replace_callback("`(<p>|<li>|<br\s*/?>|[ \n\r\t\(])((http://|https://|ftp://|mailto:|smb://|afp://|file://|gopher://|news://|ssl://|sslv2://|sslv3://|tls://|tcp://|udp://)([a-zA-Z0-9@:%_+*~#?&=.,/;-]*[a-zA-Z0-9@:%_+*~#&=/;-]))([.,?!]*?)(?=(</p>|</li>|<br\s*/?>|[ \n\r\t\)]))`i", '_filter_url_parse_full_links', $text);

  // Match www domains/addresses.
  $text = preg_replace_callback("`(<p>|<li>|[ \n\r\t\(])(www\.[a-zA-Z0-9@:%_+*~#?&=.,/;-]*[a-zA-Z0-9@:%_+~#\&=/;-])([.,?!]*?)(?=(</p>|</li>|<br\s*/?>|[ \n\r\t\)]))`i", '_filter_url_parse_partial_links', $text);
  $text = substr($text, 1, -1);

  return $text;
}

function _linkchecker_isvalid_response_code($code) {
  // TODO
  // RFC 2616 states that all unknown HTTP codes must be treated the same as the
  // base code in their class.
  $responses = array(
    100 => 'Continue', 101 => 'Switching Protocols',
    200 => 'OK', 201 => 'Created', 202 => 'Accepted', 203 => 'Non-Authoritative Information', 204 => 'No Content', 205 => 'Reset Content', 206 => 'Partial Content',
    300 => 'Multiple Choices', 301 => 'Moved Permanently', 302 => 'Found', 303 => 'See Other', 304 => 'Not Modified', 305 => 'Use Proxy', 307 => 'Temporary Redirect',
    400 => 'Bad Request', 401 => 'Unauthorized', 402 => 'Payment Required', 403 => 'Forbidden', 404 => 'Not Found', 405 => 'Method Not Allowed', 406 => 'Not Acceptable', 407 => 'Proxy Authentication Required', 408 => 'Request Time-out', 409 => 'Conflict', 410 => 'Gone', 411 => 'Length Required', 412 => 'Precondition Failed', 413 => 'Request Entity Too Large', 414 => 'Request-URI Too Large', 415 => 'Unsupported Media Type', 416 => 'Requested range not satisfiable', 417 => 'Expectation Failed',
    500 => 'Internal Server Error', 501 => 'Not Implemented', 502 => 'Bad Gateway', 503 => 'Service Unavailable', 504 => 'Gateway Time-out', 505 => 'HTTP Version not supported'
  );

  return array_key_exists($code, $responses);
}

/**
 * FIXME: If a node type is enabled.
 */
function _linkchecker_scan_nodetype($node_type = NULL) {
  $enabled = FALSE;
  $node_types = variable_get('linkchecker_scan_nodetypes', array());

  if (array_sum($node_types) > 0) {
    $enabled = $node_types[$node_type] ? TRUE : FALSE;
  }
  else {
    $enabled = TRUE;
  }

  return $enabled;
}

/**
 * Sets the status of a node to 0, meaning unpublished.
 * 
 * @param: link object
 */
function _linkchecker_unpublish_nodes($lid) {
  $res = db_query("SELECT * FROM {linkchecker_nodes} WHERE lid = %d", $lid);
  while ($row = db_fetch_object($res)) {
    $node = node_load(array('nid' => $row->nid));
    $node->status = 0;
    node_save($node);
    watchdog('linkchecker', 'Set @type %title to unpublished.', array('@type' => $node->type, '%title' => $node->title));

    // TODO: Add email notification for authors.
  }
}
